minting CCRMinter

import { 
    hasSeedUtxo, 
    validateUutMinting
} from CapoMintHelpers

const seedTxn : TxId = TxId::new(#1234)
const seedIndex : Int = 42

//!!! todo: support import from within same constellation
// !!! and get rid of these duplicated helpers
func tnRegCredUUT(credId: String) -> String {
    ("rcred-"+credId)
}
func tnLIT(credId: String) -> String {
    ("link:rcred-"+credId)
}

enum Redeemer { 
    mintingCharterToken {
        owner: Address
    }
    mintingUuts {
        seedTxn: TxId
        seedIndex: Int
        purposes: []String
    }
    commissioningNewCred {
        credId: String
    }
    mintingLIT { // Linked Interaction Token for a cred
        credId: String
    }
}

func getOutputWithValue(tx: Tx, v: Value) -> Option[TxOutput] {
    tx.outputs.find_safe(
        (txo : TxOutput) -> Bool {
            txo.value >= v
        }
    )
}

//!!! todo: honors the policy-delegate UUT for a cred
// func authorizedByExplicitToken(tx : Tx, ac: AssetClass) -> Bool {
//     v : Value = Value::new(ac, 1);
//     auth : Option[TxOutput] = getOutputWithValue(tx, v);

//     auth.switch{
//         None => false,
//         Some => true
//     }
// }

func hasContractSeedUtxo(tx: Tx) -> Bool {
    hasSeedUtxo(tx, seedTxn, seedIndex, "contract charter")
}

//!!! todo: implement me
func validateNewCredCreation( ctx: ScriptContext, creId: String ) -> Bool {
    // assert(authorizedByExplicitToken(tx, charterToken), "no charter authz");

    // settingsAndPolicyTokens : Value =  Value::new(
    //     AssetClass::new(mph, tnTokenSettings(tokenName).encode_utf8()), 1
    // ) + Value::new(
    //     AssetClass::new(mph, tnTokenPolicy(tokenName).encode_utf8()), 1
    // );

    // expectedMint : Map[ByteArray]Int = settingsAndPolicyTokens.get_policy(mph);
    // actualMint : Map[ByteArray]Int = value_minted.get_policy(mph);

    // // expectedMint.for_each( (k : ByteArray, v : Int) ->{
    // //     print("should mint "+ v.show() +"x "+ k.decode_utf8())
    // // });
    // // actualMint.for_each( (k : ByteArray, v : Int) ->{
    // //     print("is minting: "+ v.show() +"x "+ k.decode_utf8())
    // // });

    // assert(expectedMint == actualMint, "wrong tknComm mint" +
    //     "\n  ...expected: " + expectedMint.fold((s: []String, k : ByteArray, v : Int) -> []String {
    //         s.prepend(v.show() +"x "+ k.decode_utf8())
    //         }, []String{}).join("\n    +")+
    //     "\n  ...actual: " + actualMint.fold((s: []String, k : ByteArray, v : Int) -> []String {
    //         s.prepend(v.show() +"x "+ k.decode_utf8())
    //     }, []String{}).join("\n    +")
    // );

    true
}

//!!! todo: implement me
func validateLITCreation( ctx: ScriptContext, creId: String ) -> Bool {
    true
}

func main(r : Redeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    mph: MintingPolicyHash = ctx.get_current_minting_policy_hash();
    value_minted: Value = tx.minted;

    charterToken: AssetClass = AssetClass::new(
        mph,
        "charter".encode_utf8()
    );

    redeemerCheckOK : Bool = r.switch {
        charter: mintingCharterToken => {
            assert(value_minted == Value::new(charterToken, 1), "charter not minted");

            //! will mint the charter token on authority of the seed-utxo being spent
            hasContractSeedUtxo(tx) &&
            tx.outputs.all( (output: TxOutput) -> Bool {
                output.value != value_minted || (
                    output.value == value_minted &&
                    output.address == charter.owner
                )
            })
        },

        //??? disable this action because we have a more custom version?
        //  ... or, structure cred-commission as a structured call to validateUutMinting()?
        mintingUuts{sTxId, sIdx, purposes} => validateUutMinting(ctx, sTxId, sIdx, purposes),
        
        commissioningNewCred{credId} => validateNewCredCreation(ctx, credId),
        mintingLIT{credId} => validateLITCreation(ctx, credId),
        
        _ => true
    };

    // print("custom minter: minting value: " + value_minted.show());

    redeemerCheckOK
}

